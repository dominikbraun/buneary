package buneary

import "fmt"

type (
	// ExchangeType represents the type of an exchange and thus defines its routing
	// behavior. The type cannot be changed after the exchange has been created.
	ExchangeType string

	// QueueType represents the type of a queue.
	QueueType string

	// BindingType represents the type of a binding and determines whether it binds
	// to a queue - which is the default case - or to another exchange.
	BindingType string
)

const (
	// Direct will deliver messages to queues based on their routing key. A direct
	// exchange compares the routing key to all registered binding keys and forwards
	// the message to all queues with matching binding keys.
	Direct ExchangeType = "direct"

	// Headers will deliver messages to queues based on their headers. This exchange
	// type will ignore the actual routing key.
	Headers = "headers"

	// Fanout will deliver messages to all bound queues of an exchange and ignore
	// the routing key, making them suitable for broadcasting scenarios.
	Fanout = "fanout"

	// Topic will deliver messages to queues based on a binding pattern. The exchange
	// will compare the routing key to all queue binding patterns and forward the
	// message to all matching queues.
	Topic = "topic"

	// Classic represents a classic message queue without any particularities.
	Classic QueueType = "classic"

	// Quorum represents a quorum queue.
	Quorum = "quorum"

	// ToQueue represents a binding from an exchange to a queue.
	ToQueue BindingType = "queue"

	// ToExchange represents a binding from an exchange to another exchange.
	ToExchange = "exchange"
)

// Provider prescribes all functions a buneary implementation has to possess.
type Provider interface {

	// CreateExchange creates a new exchange. If an exchange with the provided name
	// already exists, nothing will happen.
	CreateExchange(config AMQPConfig, exchange Exchange) error

	// CreateQueue will create a new queue. If a queue with the provided name
	// already exists, nothing will happen. CreateQueue will return the queue
	// name generated by the server if no name has been provided.
	CreateQueue(config AMQPConfig, queue Queue) (string, error)

	// CreateBinding will create a new binding. If a binding with the provided
	// target already exists, nothing will happen.
	CreateBinding(config AMQPConfig, binding Binding) error

	// PublishMessage publishes a message to the given exchange. The exchange
	// has to exist or must be created before the message is published.
	//
	// The actual message routing is defined by the exchange type. If no routing
	// key is given, the message will be sent to the default exchange.
	PublishMessage(config AMQPConfig, exchange Exchange, message Message) error
}

// AMQPConfig stores AMQP-related configuration values.
type AMQPConfig struct {

	// Host is the AMQP broker hostname without protocol or port information, for
	// example `localhost`.
	Host string

	// Port determines the RabbitMQ AMQP port, for example 5672.
	Port uint16

	// User represents the username for setting up a connection.
	User string

	// Password represents the password to authenticate with.
	Password string
}

// URI returns the AMQP URI for a configuration, prefixed with amqp://.
func (a *AMQPConfig) URI() string {
	uri := fmt.Sprintf("amqp://%s:%s@%s:%d", a.User, a.Password, a.Host, a.Port)
	return uri
}

// Exchange represents a RabbitMQ exchange.
type Exchange struct {

	// Name is the name of the exchange. Names starting with `amq.` denote pre-
	// defined exchanges and should be avoided. A valid name is not empty and only
	// contains letters, digits, hyphens, underscores, periods and colons.
	Name string

	// Type is the type of the exchange and determines in which fashion messages are
	// routed by the exchanged. It cannot be changed afterwards.
	Type ExchangeType

	// Durable determines whether the exchange will be persisted, i.e. be available
	// after server restarts. By default, an exchange is not durable.
	Durable bool

	// AutoDelete determines whether the exchange will be deleted automatically once
	// there are no bindings to any queues left. It won't be deleted by default.
	AutoDelete bool
}

// Queue represents a message queue.
type Queue struct {

	// Name is the name of the queue. The name might be empty, in which case the
	// RabbitMQ server will generate and return a name for the queue. Queue names
	// follow the same rules as exchange names regarding the valid characters.
	Name string

	// Type is the type of the queue. Most users will only need classic queues, but
	// buneary strives to support quorum queues as well.
	//
	// For more information, see https://www.rabbitmq.com/quorum-queues.html.
	Type QueueType

	// Durable determines whether the queue will be persisted, i.e. be available after
	// server restarts. By default, an queue is not durable.
	Durable bool

	// AutoDelete determines whether the queue will be deleted automatically once
	// there are no consumers to ready from it left. It won't be deleted by default.
	AutoDelete bool
}

// Binding represents an exchange- or queue binding.
type Binding struct {

	// Type is the type of the binding and determines whether the exchange binds to
	// another exchange or to a queue. Depending on the binding type, the server will
	// look for an exchange or queue with the provided target name.
	Type BindingType

	// From is the "source" of a binding going to the target. Even though this is an
	// Exchange instance, only the exchange name is needed for creating a binding.
	//
	// To bind to a durable queue, the source exchange has to be durable as well. This
	// won't be checked on client-side, but an error will be returned by the server if
	// this constraint is not met.
	From Exchange

	// TargetName is the name of the target, which is either an exchange or a queue.
	TargetName string
}

// Message represents a message to be enqueued.
type Message struct {

	// Target is the target exchange. Even though this is an entire Exchange instance,
	// only the exchange name is required for sending a message.
	Target Exchange

	// Headers represents the message headers, which is a set of arbitrary key-value
	// pairs. Message headers are considered by some exchange types and thus can be
	// relevant for message routing.
	Headers map[string]string

	// RoutingKey is the routing key of the message and largely determines how the
	// message will be routed and which queues will receive the message. See the
	// individual ExchangeType constants for more information on routing behavior.
	RoutingKey string

	// Body represents the message body.
	Body []byte
}
