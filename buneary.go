package main

import (
	"fmt"
	"strconv"
	"strings"
	"time"

	"github.com/streadway/amqp"
)

const amqpDefaultPort = 5672

type (
	// ExchangeType represents the type of an exchange and thus defines its routing
	// behavior. The type cannot be changed after the exchange has been created.
	ExchangeType string

	// QueueType represents the type of a queue.
	QueueType string

	// BindingType represents the type of a binding and determines whether it binds
	// to a queue - which is the default case - or to another exchange.
	BindingType string
)

const (
	// Direct will deliver messages to queues based on their routing key. A direct
	// exchange compares the routing key to all registered binding keys and forwards
	// the message to all queues with matching binding keys.
	Direct ExchangeType = "direct"

	// Headers will deliver messages to queues based on their headers. This exchange
	// type will ignore the actual routing key.
	Headers = "headers"

	// Fanout will deliver messages to all bound queues of an exchange and ignore
	// the routing key, making them suitable for broadcasting scenarios.
	Fanout = "fanout"

	// Topic will deliver messages to queues based on a binding pattern. The exchange
	// will compare the routing key to all queue binding patterns and forward the
	// message to all matching queues.
	Topic = "topic"

	// Classic represents a classic message queue without any particularities.
	Classic QueueType = "classic"

	// Quorum represents a quorum queue.
	Quorum = "quorum"

	// ToQueue represents a binding from an exchange to a queue.
	ToQueue BindingType = "queue"

	// ToExchange represents a binding from an exchange to another exchange.
	ToExchange = "exchange"
)

// Provider prescribes all functions a buneary implementation has to possess.
type Provider interface {

	// CreateExchange creates a new exchange. If an exchange with the provided name
	// already exists, nothing will happen.
	CreateExchange(exchange Exchange) error

	// CreateQueue will create a new queue. If a queue with the provided name
	// already exists, nothing will happen. CreateQueue will return the queue
	// name generated by the server if no name has been provided.
	CreateQueue(queue Queue) (string, error)

	// CreateBinding will create a new binding. If a binding with the provided
	// target already exists, nothing will happen.
	CreateBinding(binding Binding) error

	// GetExchanges returns all exchanges that pass the provided filter function.
	// To get all exchanges, pass a filter function that always returns true.
	GetExchanges(filter func(exchange Exchange) bool) ([]Exchange, error)

	// GetQueues returns all queue that pass the provided filter function. To get
	// all queues, pass a filter function that always returns true.
	GetQueues(filter func(queue Queue) bool) ([]Queue, error)

	// PublishMessage publishes a message to the given exchange. The exchange
	// has to exist or must be created before the message is published.
	//
	// The actual message routing is defined by the exchange type. If no routing
	// key is given, the message will be sent to the default exchange.
	PublishMessage(message Message) error

	// DeleteExchange deletes the given exchange from the server. Will return
	// an error if the specified exchange name doesn't exist.
	DeleteExchange(exchange Exchange) error

	// DeleteQueue deletes the given queue from the server. Will return an error
	// if the specified queue name doesn't exist. DeleteQueue purges all remaining
	// messages and returns the number of purged messages.
	DeleteQueue(queue Queue) (int, error)
}

// AMQPConfig stores AMQP-related configuration values.
type AMQPConfig struct {

	// Address specifies the RabbitMQ address in the form `localhost:5672`. The
	// port is not mandatory. If there's no port, 5672 will be used as default.
	Address string

	// User represents the username for setting up a connection.
	User string

	// Password represents the password to authenticate with.
	Password string
}

// URI returns the AMQP URI for a configuration, prefixed with amqp://.
// In case the RabbitMQ address lacks a port, the default port will be used.
func (a *AMQPConfig) URI() string {
	tokens := strings.Split(a.Address, ":")
	var port string

	if len(tokens) == 2 {
		port = tokens[1]
	} else {
		port = strconv.Itoa(amqpDefaultPort)
	}

	uri := fmt.Sprintf("amqp://%s:%s@%s:%s", a.User, a.Password, tokens[0], port)

	return uri
}

// Exchange represents a RabbitMQ exchange.
type Exchange struct {

	// Name is the name of the exchange. Names starting with `amq.` denote pre-
	// defined exchanges and should be avoided. A valid name is not empty and only
	// contains letters, digits, hyphens, underscores, periods and colons.
	Name string

	// Type is the type of the exchange and determines in which fashion messages are
	// routed by the exchanged. It cannot be changed afterwards.
	Type ExchangeType

	// Durable determines whether the exchange will be persisted, i.e. be available
	// after server restarts. By default, an exchange is not durable.
	Durable bool

	// AutoDelete determines whether the exchange will be deleted automatically once
	// there are no bindings to any queues left. It won't be deleted by default.
	AutoDelete bool

	// Internal determines whether the exchange should be public-facing or not.
	Internal bool

	// NoWait determines whether the client should wait for the server confirming
	// operations related to the passed exchange. For instance, if NoWait is set to
	// false when creating an exchange, the client won't wait for confirmation.
	NoWait bool
}

// Queue represents a message queue.
type Queue struct {

	// Name is the name of the queue. The name might be empty, in which case the
	// RabbitMQ server will generate and return a name for the queue. Queue names
	// follow the same rules as exchange names regarding the valid characters.
	Name string

	// Type is the type of the queue. Most users will only need classic queues, but
	// buneary strives to support quorum queues as well.
	//
	// For more information, see https://www.rabbitmq.com/quorum-queues.html.
	Type QueueType

	// Durable determines whether the queue will be persisted, i.e. be available after
	// server restarts. By default, an queue is not durable.
	Durable bool

	// AutoDelete determines whether the queue will be deleted automatically once
	// there are no consumers to ready from it left. It won't be deleted by default.
	AutoDelete bool
}

// Binding represents an exchange- or queue binding.
type Binding struct {

	// Type is the type of the binding and determines whether the exchange binds to
	// another exchange or to a queue. Depending on the binding type, the server will
	// look for an exchange or queue with the provided target name.
	Type BindingType

	// From is the "source" of a binding going to the target. Even though this is an
	// Exchange instance, only the exchange name is needed for creating a binding.
	//
	// To bind to a durable queue, the source exchange has to be durable as well. This
	// won't be checked on client-side, but an error will be returned by the server if
	// this constraint is not met.
	From Exchange

	// TargetName is the name of the target, which is either an exchange or a queue.
	TargetName string

	// Key is the key of the binding. The key is crucial for message routing from the
	// exchange to the bound queue or to another exchange.
	Key string
}

// Message represents a message to be enqueued.
type Message struct {

	// Target is the target exchange. Even though this is an entire Exchange instance,
	// only the exchange name is required for sending a message.
	Target Exchange

	// Headers represents the message headers, which is a set of arbitrary key-value
	// pairs. Message headers are considered by some exchange types and thus can be
	// relevant for message routing.
	Headers map[string]interface{}

	// RoutingKey is the routing key of the message and largely determines how the
	// message will be routed and which queues will receive the message. See the
	// individual ExchangeType constants for more information on routing behavior.
	RoutingKey string

	// Body represents the message body.
	Body []byte
}

// buneary is an implementation of the Provider interface with sane defaults.
type buneary struct {
	channel *amqp.Channel
	config  *AMQPConfig
}

// setupConnection dials the configured RabbitMQ server, sets up a connection and opens
// a channel from that connection, which should be closed once buneary has finished.
func (b *buneary) setupConnection() error {
	if b.channel != nil {
		if err := b.channel.Close(); err != nil {
			return err
		}
	}

	conn, err := amqp.Dial(b.config.URI())
	if err != nil {
		return err
	}

	if b.channel, err = conn.Channel(); err != nil {
		return err
	}

	return nil
}

// CreateExchange creates the given exchange. See Provider.CreateExchange for details.
func (b *buneary) CreateExchange(exchange Exchange) error {
	if err := b.setupConnection(); err != nil {
		return err
	}

	if err := b.channel.ExchangeDeclare(exchangeArgs(exchange)); err != nil {
		return err
	}

	return nil
}

// CreateQueue creates the given queue. See Provider.CreateQueue for details.
func (b *buneary) CreateQueue(queue Queue) (string, error) {
	if err := b.setupConnection(); err != nil {
		return "", err
	}

	q, err := b.channel.QueueDeclare(queueArgs(queue))
	if err != nil {
		return "", err
	}

	return q.Name, nil
}

// CreateBinding creates the given binding. See Provider.CreateBinding for details.
func (b *buneary) CreateBinding(binding Binding) error {
	if err := b.setupConnection(); err != nil {
		return err
	}

	if err := b.channel.QueueBind(bindingArgs(binding)); err != nil {
		return err
	}

	return nil
}

// GetExchanges returns exchanges passing the filter. See Provider.GetExchanges for details.
func (b *buneary) GetExchanges(filter func(exchange Exchange) bool) ([]Exchange, error) {
	return nil, nil
}

// GetQueues returns queues passing the filter. See Provider.GetQueues for details.
func (b *buneary) GetQueues(filter func(queue Queue) bool) ([]Queue, error) {
	return nil, nil
}

// PublishMessage publishes the given message. See Provider.PublishMessage for details.
func (b *buneary) PublishMessage(message Message) error {
	if err := b.setupConnection(); err != nil {
		return err
	}

	if err := b.channel.Publish(messageArgs(message)); err != nil {
		return err
	}

	return nil
}

// DeleteExchange deletes the given exchange. See Provider.DeleteExchange for details.
func (b *buneary) DeleteExchange(exchange Exchange) error {
	if err := b.setupConnection(); err != nil {
		return err
	}

	if err := b.channel.ExchangeDelete(exchange.Name, false, false); err != nil {
		return err
	}

	return nil
}

// DeleteQueue deletes the given exchange. See Provider.DeleteQueue for details.
func (b *buneary) DeleteQueue(queue Queue) (int, error) {
	if err := b.setupConnection(); err != nil {
		return 0, err
	}

	purged, err := b.channel.QueueDelete(queue.Name, false, false, false)
	if err != nil {
		return 0, err
	}

	return purged, nil
}

// Close closes the AMQP channel to the configured RabbitMQ server. This function
// should be called after each operation defined by the Provider interface.
func (b *buneary) Close() error {
	return b.channel.Close()
}

// exchangeArgs returns all exchange fields expected by the AMQP library as single
// values. This avoids large parameter lists when calling library function.
func exchangeArgs(exchange Exchange) (string, string, bool, bool, bool, bool, amqp.Table) {
	return exchange.Name,
		string(exchange.Type),
		exchange.Durable,
		exchange.AutoDelete,
		exchange.Internal,
		exchange.NoWait,
		amqp.Table{}
}

// queueArgs returns all queue fields expected by the AMQP library as single values.
// This avoids large parameter lists when calling library functions.
//
// ToDo: Store key-value arguments in the queue and provide them from there.
func queueArgs(queue Queue) (string, bool, bool, bool, bool, amqp.Table) {
	return queue.Name,
		queue.Durable,
		queue.AutoDelete,
		false,
		false,
		amqp.Table{}
}

// bindingArgs returns all binding fields expected by the AMQP library as single
// values. This avoids large parameter lists when calling library functions.
//
// ToDo: Store key-value arguments in the binding and provide them from there.
func bindingArgs(binding Binding) (string, string, string, bool, amqp.Table) {
	return binding.TargetName,
		binding.Key,
		binding.From.Name,
		false,
		amqp.Table{}
}

// messageArgs returns all message fields expected by the AMQP library as single
// values. This avoids large parameter lists when calling library functions.
func messageArgs(message Message) (string, string, bool, bool, amqp.Publishing) {
	return message.Target.Name,
		message.RoutingKey,
		false,
		false,
		amqp.Publishing{
			Headers:   message.Headers,
			Timestamp: time.Now(),
			Body:      message.Body,
		}
}
